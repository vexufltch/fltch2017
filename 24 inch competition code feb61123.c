#pragma config(Sensor, dgtl1,  Encoder1,       sensorQuadEncoder)
#pragma config(Motor,  port1,           driveFL,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           driveBL,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           intakeL,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           outerL,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           innerL,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           innerR,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           outerR,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           intakeR,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           driveBR,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          driveFR,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define SHOOTER_RPM					630
#define PID_SENSOR_INDEX    Encoder1

// For RPM calculation
#define time = 25 // Update Interval
#define ticks = 360 // Ticks per full encoder revolution

#define ENCODER_CONVERSION 	0.006 			// Encode Pulses/ms
#define UPDATE_INTERVAL  		25  				// In ms
#define MS_PER_MIN						60000			//
#define REV_PER_ENCODER_TICK  0.00277   // 1 rev / 360 ticks

#define FL_MOTOR_TUNE 0
#define BL_MOTOR_TUNE 0
#define BR_MOTOR_TUNE 0
#define FR_MOTOR_TUNE 0


#define PID_DRIVE_MAX       (-60)											//CHANGED FROM 127 TO PREVENT MOTOR BACKLASH
#define PID_DRIVE_MIN     	(-95)										//changed from -127 for demonstration/low stress purpose

static bool   pidRunning = false; 						// Enable/Disable PID, 1 for true, 0 for false
static float pidRequestedVelocity = 0; 	// Set PID RPM

static bool enableIntake = true;

#define INTAKE_SPEED 						110
#define INTAKE_SPEED_REVERSE		-110

//int Hz = 1000 / time;
float RPM;
float motorPower = 0;
int motorPowerIntake = 0;


//int sum = add(4,5);

void updateShooterRPM(){
		RPM = abs(SensorValue[Encoder1]) * REV_PER_ENCODER_TICK * (1/UPDATE_INTERVAL) * MS_PER_MIN;
}

void setShooterSpeed(int s){
		motor[outerL] = -s;
		motor[innerR] = -s;
		motor[outerR] = s;
		motor[innerL] = s;
}

void setIntakeSpeed(int s){
	motor[intakeL]=  -s;
	motor[intakeR]=  s;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

	float  pid_Kp = 21/2;																																					//CHANGED FROM 1.10
		float  pid_Ki = 0.74/2;																																				//CHANGED FROM .5
		float  pid_Kd = 20.0/2;																																				//CHANGED FROM 1.01
		float  pidSensorCurrentValue;
		float  pidError;
    float  pidLastError;
    float  pidIntegral;
    float  pidDerivative;
    float  pidDrive;
    float  pidSetSensorValue;

task pidController()
{

	// These could be constants but leaving
		// asPID_SENSOR_INDEX variables allows them to be modified in the debugger "live"


    // If we are using an encoder then clear it
    if( SensorType[ PID_SENSOR_INDEX ] == sensorQuadEncoder )
        SensorValue[ PID_SENSOR_INDEX ] = 0;

    // Init the variables - thanks Glenn :)
    pidLastError  = 0;
    pidIntegral   = 0;

    while( true )
        {
        // Is PID control active ?
        if( pidRunning )
            {
            // Read the sensor value and scale
            pidSensorCurrentValue = -SensorValue[  ];

						// Determine desired sensor value
            pidSetSensorValue = pidRequestedVelocity * ENCODER_CONVERSION * UPDATE_INTERVAL;

            // calculate error (0.006 units/ms)
            pidError = pidSensorCurrentValue - pidSetSensorValue;

            SensorValue[ PID_SENSOR_INDEX ] = 0;

            // integral - if Ki is not 0

            // calculate the derivative
            pidDerivative = abs(pidError - pidLastError);

            if( pid_Ki != 0 ){
            	if(abs(pidIntegral) <= PID_DRIVE_MAX ){
                pidIntegral = pidIntegral +pidError;
              }
              else{
              	if(pidError < 10){
              	pidIntegral = pidIntegral + abs(pidError);
              }
}          }     else{

                pidIntegral = 0;

            }
						if(pidIntegral >0){
							pidIntegral = 0;

}           pidLastError  = pidError;

            // calculate drive
            pidDrive = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

            // limit drive
            if( pidDrive > PID_DRIVE_MAX )
                pidDrive = PID_DRIVE_MAX;
            if( pidDrive < PID_DRIVE_MIN )
                pidDrive = PID_DRIVE_MIN;

            // send to motor
            //motor[ PID_MOTOR_INDEX ] = pidDrive * PID_MOTOR_SCALE;
                setShooterSpeed(pidDrive);
            }
        else
            {
            // clear all
            pidError      = 0;
            pidLastError  = 0;
            pidIntegral   = 0;
            pidDerivative = 0;
            setShooterSpeed(0);
            }
        wait1Msec( UPDATE_INTERVAL );
        }
}



task intake(){
	while(true){
		if(enableIntake){
			if(vexRT[Btn5U]){
				setIntakeSpeed(INTAKE_SPEED);
			}
			else{
				if(vexRT[Btn5D]){
					setIntakeSpeed(INTAKE_SPEED_REVERSE);
				}
				else{
					setIntakeSpeed(0);
				}
			}
		}
	}
		wait1Msec(UPDATE_INTERVAL);
}

task drive(){
	//Holonomic
while(true){
			motor[driveFL] = -vexRT[Ch3]+vexRT[Ch4]+vexRT[Ch1];
			motor[driveBL] = -vexRT[Ch3]-vexRT[Ch4]+vexRT[Ch1];
			motor[driveBR] = vexRT[Ch3]-vexRT[Ch4]+vexRT[Ch1];
			motor[driveFR] = vexRT[Ch3]+vexRT[Ch4]+vexRT[Ch1];
			wait1Msec(UPDATE_INTERVAL);
		}
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

	startTask(pidController);

	pidRequestedVelocity= SHOOTER_RPM;		//Increase to increase distance. Decrease to decrease distance
	pidRunning = true;
	while(true){
	setIntakeSpeed(INTAKE_SPEED);
		wait1Msec( UPDATE_INTERVAL );
	}
}

task usercontrol()
{
	//	pidRequestedVelocity= SHOOTER_RPM;		//Increase to increase distance. Decrease to decrease distance
		//pidRunning = true;
		startTask(pidController);
		startTask(drive);
		startTask(intake);
		bool buttonHasBeenPressed = false;
		while (true)
	{
		//shooter code
	   if(!buttonHasBeenPressed){
			if(vexRT[Btn6U] ){
				buttonHasBeenPressed= true;
				if(pidRunning){
					pidRunning = false;
				}
				else{
					pidRequestedVelocity= SHOOTER_RPM;		//Increase to increase distance. Decrease to decrease distance
					pidRunning = true;
				}
			}
			else{
			}
		}

			if(vexRT[Btn6U] != 1){
				buttonHasBeenPressed = false;


			}

			wait1Msec( UPDATE_INTERVAL );
	}
}
