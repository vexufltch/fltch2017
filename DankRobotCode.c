#pragma config(Sensor, dgtl1,  ArmEncoder,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  sonar,          sensorSONAR_inch)
#pragma config(Sensor, dgtl5,  LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  RightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           strafe1,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           driveLeft,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           driveRight,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port4,           strafe2,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           liftLeftTop,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftLeftBottom, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           liftRightTop,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           liftRightBottom, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           punch1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          punch2,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*#pragma config(Motor,  port3,           driveFrontLeft, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port1,          driveFrontRight, tmotorVex393_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*/

#define ArmTolerance 0
//float encoderVal;
int ArmTarget = 0;
int ArmEncoderVal = 0;

int setpoint = 360;

float Kp = 0.0;
float Ki = 0.0;
float Kd = 0.0;

float gError = 0.0;

/*task setArmPos() {
	while(abs(ArmEncoderVal-ArmTarget)<ArmTolerance) {
		if (ArmEncoderVal > ArmTarget) {

	}
	int ArmEncoderVal = SensorValue(ArmEncoder);


}*/

int pControl(int current) {
	float error = (float)(setpoint - current);

	gError = error;
	int result = Kp*error;

	if(abs(result) > 127 ){
		if(result < 0)
			result = -127;
		else
			result= 127;
}

	return result;
}

int iControl (int current) {
	return 0;
}

task main(){
	int sonarIntVal = 0;
	int LeftEncoderVal = 0;
	int RightEncoderVal = 0;
	while(true){
		ArmEncoderVal = SensorValue(ArmEncoder);
		/*ArmFloat = (360.0 - ArmEncoderVal)/360.0;
		//tank drive
	if (ArmEncoderVal < 360) {
		motor[driveLeft]	= -50 * ArmFloat;
		//motor[driveRight] = vexRT[Ch2];
	} else {
		motor[driveLeft]	= 0;
		motor[driveRight] = 0;
	}*/


	motor[driveLeft]=-pControl(ArmEncoderVal);
		/*motor[driveFrontLeft] = vexRT[Ch3] ;
		motor[driveFrontRight] = vexRT[Ch2];*/

		//better drive
		/*
		motor[driveLeft] 	= vexRT[Ch3] + vexRT[Ch1];
		motor[driveRight] =	vexRT[Ch3] - vexRT[Ch1];
		motor[strafe1]		= vexRT[Ch4];
		motor[strafe2]		= -vexRT[Ch4];
		*/

		//Arm motors
		if(vexRT[Btn6U]==1){
			motor[liftLeftTop]=-127;
			motor[liftLeftBottom]=-127;
			motor[liftRightTop]=127;
			motor[liftRightBottom]=127;
			} else if(vexRT[Btn6D]==1){
			motor[liftLeftTop]=63;
			motor[liftLeftBottom]=63;
			motor[liftRightTop]=-63;
			motor[liftRightBottom]=-63;
			} else{
			motor[liftLeftTop]=25;
			motor[liftLeftBottom]=25;
			motor[liftRightTop]=25;
			motor[liftRightBottom]=25;
		}

		//Puncher motors
		/*if(vexRT[Btn5U]==1){
			motor[punch1]=127;
			motor[punch2]=-127;
			}	else if (vexRT[Btn5D]==1){ // might not need power release
			motor[punch1]=-127;
			motor[punch2]=127;
			} else {
			motor[punch1]=0;
			motor[punch2]=0;
		}*/

		//Sensor test
		sonarIntVal = SensorValue(sonar);
		ArmEncoderVal = SensorValue(ArmEncoder);
		LeftEncoderVal = SensorValue(LeftEncoder);
		RightEncoderVal = SensorValue(RightEncoder);



		// holonomic drive
		/*motor[driveBackLeft] = vexRT[Ch1] - vexRT[Ch4] + vexRT[Ch3];
		motor[driveBackRight] = vexRT[Ch1] - vexRT[Ch4] - vexRT[Ch3];
		motor[driveFrontLeft] = vexRT[Ch1] + vexRT[Ch4] + vexRT[Ch3];
		motor[driveFrontRight] = vexRT[Ch1] + vexRT[Ch4] - vexRT[Ch3];*/
		//encoderVal=SensorValue[Encoder1];
	}

	/*while(1){
	RPMCalc();
	while(RPM < 550 && RPM > 475){ // get rpm Calculation method
	motor[intakeL] = -127;
	motor[intakeR] = 127;
	}
	wait1Msec(50);
	motorPower += 5;
	motor[outerL] = motorPower;
	motor[innerR] = motorPower;
	motor[outerR] = -motorPower;
	motor[innerL] = -motorPower;
	}*/
}
