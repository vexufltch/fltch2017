#pragma config(Sensor, dgtl1,  ArmEncoder,     sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  RightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           clawLeft,      tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           driveLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           liftLeftMiddle, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           liftLeftBottom, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftRightBottom, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           liftRightTop,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveRight_,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          clawRight,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
void driveStraight(float distance){
	//this method should drive either forward or backwards by a number of inches defined by the distance parameter
		//front wheel axis is 14.5 away from back of robot
		float LeftEncoderStart = SensorValue[LeftEncoder];
		float RightEncoderStart = SensorValue[RightEncoder];
		float encoderChange = 0;
		float ticksNeeded =distance/12.566*360; // number of ticks needed
		//                           ^^^ MAGIC NUMBER
		//17.5 = fork length
		do {
			float RightEncoderStop = SensorValue[RightEncoder];
			encoderChange = abs(RightEncoderStop) - abs(RightEncoderStart);
			if (ticksNeeded > 0 && abs(ticksNeeded) > abs(encoderChange)){
				motor[driveLeft] = 127;
				motor[driveRight_] = -127;
			} else if (ticksNeeded < 0 && abs(ticksNeeded) > abs(encoderChange)){
				motor[driveLeft] = -127;
				motor[driveRight_] = 127;
			}else {
				motor[driveLeft] = 0;
				motor[driveRight_] = 0;
			}
		} while(abs(encoderChange) < abs(ticksNeeded));
		/*while(((float) SensorValue(RightEncoder) < rotationsNeeded) && ((float) SensorValue(LeftEncoder) < rotationsNeeded)){
			if (rotatonsNeeded > (float) SensorValue(RightEncoder){
				motor[driveLeft] = 127;
				motor[driveRight] = - 127;
			} else {
				motor[driveLeft] = 127;
				motor[driveRight] = - 127;
			}
		}*/
}



void liftLift () {
	motor[liftLeftMiddle]=-127;//lifts lift
	motor[liftLeftBottom]=-127;
	motor[liftRightTop]=127;
	motor[liftRightBottom]=127;
	//wait1Msec(500); // using waits inside functions is dangerous
}

void liftLift (int p) {
	motor[liftLeftMiddle]=-p;//lifts lift
	motor[liftLeftBottom]=-p;
	motor[liftRightTop]=p;
	motor[liftRightBottom]=p;
	//wait1Msec(500); // using waits inside functions is dangerous
}

void lowerLift () {
	motor[liftLeftMiddle]=127;//lifts lift
	motor[liftLeftBottom]=127;
	motor[liftRightTop]=-127;
	motor[liftRightBottom]=-127;
}

void lowerLift (int p) {
	motor[liftLeftMiddle]=p;//lifts lift
	motor[liftLeftBottom]=p;
	motor[liftRightTop]=-p;
	motor[liftRightBottom]=-p;
}

void openClaw () {
	motor[clawLeft] = -127;
	motor[clawRight] = 127;
}

void closeClaw () {
	motor[clawLeft] = 127;
	motor[clawRight] = -127;
}

void idleClaw () {
	motor[clawLeft] = 0;
	motor[clawRight] = 0;
}

void idleLift() {
	motor[liftLeftMiddle] = 0;
	motor[liftLeftBottom] = 0;
	motor[liftRightTop] = 0;
	motor[liftRightBottom] = 0;
}

void ezDump() {
	openClaw();
	wait1Msec(2500);
	// put in preloads
	closeClaw();
	wait1Msec(1500);

	idleClaw();

	driveStraight(-60); // back up
	wait1Msec(100);
	liftLift();
	wait1Msec(2000);

	openClaw();

	// 1 full throw
	wait1Msec(1000);

	idleClaw();

	lowerLift();
	closeClaw();
	wait1Msec(750); // was this left out for a reason?
	idleLift();
	closeClaw();

	wait1Msec(100);
	idleClaw();
	driveStraight(60);
	wait1Msec(1500);


	//openClaw();
	//wait1Msec(1500);
	//idleClaw();
	// 1 cycle complete
}

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// start facing the driver
	driveStraight(-18); // back up slightly
	wait1Msec(10);
	openClaw();
	wait1Msec(500);
	liftLift();
	wait1Msec(200);
	idleLift();
	ezDump();
	ezDump();
	ezDump();

	//driveStraight(-72);
	//wait1Msec(100);
	//motor[liftLeftMiddle]=-127;
	//motor[liftLeftBottom]=-127;
	//motor[liftRightTop]=127;
	//motor[liftRightBottom]=127;


	//motor[clawLeft] = 0;
	//motor[clawRight] = 0;

	//wait1Msec(2000);
	//motor[clawLeft] = -127;// opens claw!!!!
	//motor[clawRight] = 127;

	//motor[clawLeft] = 0;
	//motor[clawRight] = 0;

/*	driveStraight(-2);
	motor[clawLeft] = 127;
	motor[clawRight] = -127;
	wait1Msec(3000);

	motor[clawLeft] = -127;
	motor[clawRight] = 127;
	wait1Msec(1000);
	driveStraight(-24);
	motor[liftLeftMiddle]=-127;
	motor[liftLeftBottom]=-127;
	motor[liftRightTop]=127;
	motor[liftRightBottom]=127;
	wait10Msec(2000);
	motor[clawLeft] = 127;
	motor[clawRight] = -127;
	*/
	/*
		//Expand Intake
		//motor[liftLeftTop]=-90;
		motor[liftLeftBottom]=-90;
		motor[liftRightTop]=90;
		motor[liftRightBottom]=90;
		wait1Msec(1100);
		//motor[liftLeftTop]=63;
		motor[liftLeftBottom]=63;
		motor[liftRightTop]=-63;
		motor[liftRightBottom]=-63;
		wait1Msec(2000);
		//motor[liftLeftTop]=-127;
		motor[liftLeftBottom]=-127;
		motor[liftRightTop]=127;
		motor[liftRightBottom]=127;
		wait1Msec(500);
		//motor[liftLeftTop]=0;
		motor[liftLeftBottom]=0;
		motor[liftRightTop]=0;
		motor[liftRightBottom]=0;
		wait1Msec(1000);
		//Drive Forward
		motor[driveLeft] = 127;
		motor[driveRight_] = -127;
		wait1Msec(5000);
		motor[driveLeft] = 0;
		motor[driveRight_] = 0;
	*/
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
task usercontrol(){

	int ArmEncoderVal;
	int LeftEncoderVal = 0;
	int RightEncoderVal = 0;
	int clawState = 0;
	int idleClaw = 25; // REFACTORING!
	int clawTime = nSysTime;
	while(true){
		ArmEncoderVal = SensorValue(ArmEncoder);
		/*ArmFloat = (360.0 - ArmEncoderVal)/360.0;
		//tank drive
	if (ArmEncoderVal < 360) {
		motor[driveLeft]	= -50 * ArmFloat;
		//motor[driveRight] = vexRT[Ch2];
	} else {
		motor[driveLeft]	= 0;
		motor[driveRight] = 0;
	}*/


	//motor[driveLeft]=-pControl(ArmEncoderVal);
		motor[driveLeft] = -vexRT[Ch2];
		motor[driveRight_] = vexRT[Ch3];

		//Claw Motors
		// 0: Neutral
		// 1: Opening
		// -1: Closing
		// Btn5U: Open
		// Btn5D: Close
		// CLAWRIGHT IS REVERSED!

		if (vexRT[Btn5U]==1 && vexRT[Btn5D]==1) { // you really shouldn't ever do this
			clawState = 0;
			motor[clawLeft] = 0;
			motor[clawRight] = 0;
		} else if (vexRT[Btn5U] == 1) {
			clawState = 1;
			//clawTime = nSysTime; // for claw timeout
			clearTimer(timer1);
			motor[clawLeft]=127;
			motor[clawRight]=-127;
		} else if (vexRT[Btn5D]==1) {
			clawState = -1;
			motor[clawLeft]=-127;
			motor[clawRight]=127;
		} else {
			motor[clawLeft] = idleClaw * clawState;
			motor[clawRight]= -idleClaw * clawState;
		}
		if (clawState == 1) { // if claw has been opening for more than 2 seconds, we can probably let it rest
			if (time1[timer1] >= 2000) {
				clawState = 0;
			}
		}

		//Arm motors
			if (vexRT[Btn7U]==1) { // let motors cool down before a hang
				motor[liftLeftBottom]=0;
				motor[liftLeftMiddle]=0;
				motor[liftRightTop]=0;
				motor[liftRightBottom]=0;
			} else if(vexRT[Btn7D]==1) { // full power down for hanging
				motor[liftLeftBottom]=127;
				motor[liftLeftMiddle]=127;
				motor[liftRightTop]=-127;
				motor[liftRightBottom]=-127;
			} else if(vexRT[Btn6U]==1){
				//motor[liftLeftTop]=-127;
				motor[liftLeftBottom]=-127;
				motor[liftLeftMiddle]=-127;
				motor[liftRightTop]=127;
				motor[liftRightBottom]=127;
				//motor[liftRightMiddle]=127;
			} else if(vexRT[Btn6D]==1){
				//motor[liftLeftTop]=63;
				motor[liftLeftBottom]=30;
				motor[liftLeftMiddle]=30;
				motor[liftRightTop]=-30;
				motor[liftRightBottom]=-30;
				//motor[liftRightMiddle]=-63;
			} else if (vexRT[Btn8D]  == 1){
				motor[liftLeftMiddle]=0;
	motor[liftLeftBottom]=0;
	motor[liftRightTop]=0;
	motor[liftRightBottom]=0;

	motor[liftLeftMiddle]=-127;
	motor[liftLeftBottom]=-127;
	motor[liftRightTop]=127;
	motor[liftRightBottom]=127;
			}else if (vexRT[Btn8R] == 1){
			/////autonomous tester!!!!
	driveStraight(-2);
	wait1Msec(10);
	motor[clawLeft] = -127;//open claw
	motor[clawRight] = 127;
	wait1Msec(2000);

	motor[clawLeft] = 127;
	motor[clawRight] = -127;
	wait1Msec(1500);

	motor[clawLeft] = 0;
	motor[clawRight] = 0;

	driveStraight(-65);
	wait1Msec(100);
	motor[liftLeftMiddle]=-127;//lifts lift
	motor[liftLeftBottom]=-127;
	motor[liftRightTop]=127;
	motor[liftRightBottom]=127;
	wait1Msec(1700);

	motor[clawLeft] = -127;// opens claw!!!!
	motor[clawRight] = 127;


	// 1 full throw
	wait1Msec(1000);

	motor[clawLeft] = 0;
	motor[clawRight] = 0;

	motor[liftLeftMiddle]=127;
	motor[liftLeftBottom]=127;
	motor[liftRightTop]=-127;
	motor[liftRightBottom]=-127;
	motor[clawLeft] = -127;
	motor[clawRight] = 127;



	motor[clawLeft] = 0;
	motor[clawRight] = 0;

	wait1Msec(100);
	driveStraight(65);
	wait1Msec(1500);

	motor[clawLeft] = 127;
	motor[clawRight] = -127;

	wait1Msec(1500);

	driveStraight(-65);


	motor[liftLeftMiddle]=0;
	motor[liftLeftBottom]=0;
	motor[liftRightTop]=0;
	motor[liftRightBottom]=0;
	wait1Msec(10);

	liftLift();
	//wait1Msec(2000);
	motor[clawLeft] = -127;// opens claw!!!!
	motor[clawRight] = 127;

	motor[clawLeft] = 0;
	motor[clawRight] = 0;
	//2nd throw!?
	} else {
				//motor[liftLeftTop]=0;
				motor[liftLeftBottom]=-15;
				motor[liftLeftMiddle]=-15;
				motor[liftRightTop]=15;
				motor[liftRightBottom]=15;
				//motor[liftRightMiddle]=0;
			}
		//
		//
		//
		// AUTO TEST STUFF WENT HERE
		//
		//
		// See AUTOTESTSTUFF.TXT

		//Sensor test
		ArmEncoderVal = SensorValue(ArmEncoder);
		LeftEncoderVal = SensorValue(LeftEncoder);
		RightEncoderVal = SensorValue(RightEncoder);

	}

	/*while(1){
	RPMCalc();
	while(RPM < 550 && RPM > 475){ // get rpm Calculation method
	motor[intakeL] = -127;
	motor[intakeR] = 127;
	}
	wait1Msec(50);
	motorPower += 5;
	motor[outerL] = motorPower;
	motor[innerR] = motorPower;
	motor[outerR] = -motorPower;
	motor[innerL] = -motorPower;
	}*/


}
